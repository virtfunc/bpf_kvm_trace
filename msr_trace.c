#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
#include <bpf/libbpf.h>
#include <bpf/bpf.h>
#include <linux/types.h>
#include <getopt.h>
#include <sys/ioctl.h>
#include "msr_trace.h"
#include "msr_trace.skel.h" // Generated by bpftool

// Simple tracking for "seen" MSRs to handle the '*' prefix
#define MAX_SEEN_MSRS 4096
static unsigned int seen_msrs[MAX_SEEN_MSRS];
static int seen_count = 0;

// Buffer for batching events to print every 200ms
#define MAX_BUFFERED_EVENTS 100000
static struct event buffered_events[MAX_BUFFERED_EVENTS];
static int buffered_count = 0;
static unsigned long long userspace_drops = 0;
static int dedupe_mode = 0;

// Persistent storage for unique MSRs in dedupe mode
static struct event unique_events[MAX_SEEN_MSRS];
static int unique_count = 0;

static int cmp_event_ts_desc(const void *a, const void *b) {
    const struct event *ea = a;
    const struct event *eb = b;
    if (ea->ts > eb->ts) return -1;
    if (ea->ts < eb->ts) return 1;
    return 0;
}

static int is_seen(unsigned int msr) {
    for (int i = 0; i < seen_count; i++) {
        if (seen_msrs[i] == msr) return 1;
    }
    return 0;
}

static void mark_seen(unsigned int msr) {
    if (seen_count < MAX_SEEN_MSRS) {
        seen_msrs[seen_count++] = msr;
    }
}

static int handle_event(void *ctx, void *data, size_t data_sz)
{
    const struct event *e = data;
    if (buffered_count < MAX_BUFFERED_EVENTS) {
        buffered_events[buffered_count++] = *e;
    } else {
        userspace_drops++;
    }
    return 0;
}

static void print_event(struct event *e, char prefix, unsigned long long current_time_ns)
{
    unsigned int ago_ms = (current_time_ns - e->ts) / 1000000;
    const char *mode = e->is_write ? "WR" : "RD";

    if (e->result == 0) {
        printf("%c%sMSR: 0x%08x RIP: 0x%016llx Value: 0x%016llx -> %u ms ago\n",
               prefix, mode, e->msr, e->rip, e->value, ago_ms);
    } else {
        printf("%c%sMSR: 0x%08x RIP: 0x%016llx Value: FAULT (Except #%2d) -> %u ms ago\n",
               prefix, mode, e->msr, e->rip, e->exception, ago_ms);
    }
}

static void flush_events(unsigned long long current_time_ns)
{
    if (dedupe_mode) {
        // Update persistent unique events list with new buffered events
        for (int i = 0; i < buffered_count; i++) {
            struct event *new_e = &buffered_events[i];
            int found = 0;
            for (int j = 0; j < unique_count; j++) {
                if (unique_events[j].msr == new_e->msr) {
                    unique_events[j] = *new_e; // Update with newest
                    found = 1;
                    break;
                }
            }
            if (!found && unique_count < MAX_SEEN_MSRS) {
                unique_events[unique_count++] = *new_e;
            }
        }

        // Sort unique_events by time descending (newest first)
        qsort(unique_events, unique_count, sizeof(struct event), cmp_event_ts_desc);

        int is_tty = isatty(STDOUT_FILENO);
        if (is_tty) {
            // Clear screen and move cursor to top
            printf("\033[2J\033[H");
        }

        struct winsize w;
        int max_rows = unique_count;
        if (is_tty && ioctl(STDOUT_FILENO, TIOCGWINSZ, &w) != -1 && w.ws_row > 1) {
            if (max_rows > w.ws_row - 1)
                max_rows = w.ws_row - 1;
        }

        // If it's a TTY, print up to max_rows, otherwise print all unique events.
        for (int i = 0; i < (is_tty ? max_rows : unique_count); i++) { // Pass current_time_ns
            print_event(&unique_events[i], '*', current_time_ns);
        }
    } else {
        // Default mode: print all buffered events
        for (int i = 0; i < buffered_count; i++) {
            struct event *e = &buffered_events[i];
            char prefix = '*';

            if (is_seen(e->msr)) {
                prefix = ' ';
            } else {
                mark_seen(e->msr);
            }

            print_event(e, prefix, current_time_ns); // Pass current_time_ns
        }
    }
    buffered_count = 0;
}

static unsigned long long get_ktime_ns(void)
{
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return (unsigned long long)ts.tv_sec * 1000000000ull + ts.tv_nsec;
}

int main(int argc, char **argv)
{
    struct msr_trace_bpf *skel;
    struct ring_buffer *rb = NULL;
    int err;

    static struct option long_options[] = {
        {"dedupe", no_argument, 0, 'd'},
        {0, 0, 0, 0}
    };
    int opt;
    while ((opt = getopt_long(argc, argv, "d", long_options, NULL)) != -1) {
        switch (opt) {
        case 'd':
            dedupe_mode = 1;
            break;
        default:
            fprintf(stderr, "Usage: %s [-d|--dedupe]\n", argv[0]);
            return 1;
        }
    }

    // Set up libbpf logging
    libbpf_set_print(NULL);

    // Open and load BPF application
    skel = msr_trace_bpf__open();
    if (!skel) {
        fprintf(stderr, "Failed to open and load BPF skeleton (do you have perms?)\n");
        return 1;
    }

    // Load & Verify
    err = msr_trace_bpf__load(skel);
    if (err) {
        fprintf(stderr, "Failed to load and verify BPF skeleton (do you have perms?)\n");
        goto cleanup;
    }

    // Attach tracepoints
    err = msr_trace_bpf__attach(skel);
    if (err) {
        fprintf(stderr, "Failed to attach BPF skeleton (do you have perms?)\n");
        goto cleanup;
    }

    // Set up ring buffer
    rb = ring_buffer__new(bpf_map__fd(skel->maps.rb), handle_event, NULL, NULL);
    if (!rb) {
        err = -1;
        fprintf(stderr, "Failed to create ring buffer\n");
        goto cleanup;
    }

    printf("Tracing MSRs...\n");

    int dropped_fd = bpf_map__fd(skel->maps.dropped);
    unsigned long long last_print_ts = get_ktime_ns();

    while (1) {
        // Poll for events (wait up to 10ms)
        err = ring_buffer__poll(rb, 10);
        if (err < 0) {
            fprintf(stderr, "Error polling ring buffer: %d\n", err);
            break;
        }
        
        // Consume all available events in the buffer
        err = ring_buffer__consume(rb);
        if (err < 0) {
            fprintf(stderr, "Error consuming ring buffer: %d\n", err);
            break;
        }

        unsigned long long now = get_ktime_ns();
        if ((now - last_print_ts) > 200000000ULL) {
            flush_events(now);
            last_print_ts = now;
        }

        if (userspace_drops > 0) {
            flush_events(now);
            fprintf(stderr, "\nError: Lost %llu events (userspace buffer full)\n", userspace_drops);
            err = -1;
            break;
        }

        __u32 key = 0;
        __u64 val = 0;
        if (bpf_map_lookup_elem(dropped_fd, &key, &val) == 0) {
            if (val > 0) {
                fprintf(stderr, "Error: Lost %llu events (ring buffer full)\n", (unsigned long long)val);
                err = -1;
                break;
            }
        }
    }

cleanup:
    ring_buffer__free(rb);
    msr_trace_bpf__destroy(skel);
    return -err;
}
